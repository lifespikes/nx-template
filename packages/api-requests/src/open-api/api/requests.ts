/**
 * Generated by orval v6.23.0 üç∫
 * Do not edit manually.
 * Educal
 * API description
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import { faker } from '@faker-js/faker';
import { HttpResponse, delay, http } from 'msw';
import useAppControllerGetDataMutator from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import type { ErrorType as AppControllerGetDataErrorType } from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import useAuthControllerLoginMutator from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import type {
  ErrorType as AuthControllerLoginErrorType,
  BodyType as AuthControllerLoginBodyType,
} from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import useUsersControllerCreateMutator from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import type {
  ErrorType as UsersControllerCreateErrorType,
  BodyType as UsersControllerCreateBodyType,
} from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import useUsersControllerFindAllMutator from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import type { ErrorType as UsersControllerFindAllErrorType } from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import useUsersControllerFindOneMutator from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import type { ErrorType as UsersControllerFindOneErrorType } from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import useUsersControllerUpdateMutator from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import type {
  ErrorType as UsersControllerUpdateErrorType,
  BodyType as UsersControllerUpdateBodyType,
} from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import useUsersControllerRemoveMutator from '../../../../../apps/frontend/src/lib/mutator/custom-client';
import type { ErrorType as UsersControllerRemoveErrorType } from '../../../../../apps/frontend/src/lib/mutator/custom-client';
export interface UpdateUserDto {
  email?: string;
  isVerified?: boolean;
  name?: string;
  password?: string;
  phone?: string;
}

export interface UserEntity {
  createdAt: string;
  email: string;
  id: number;
  isVerified: boolean;
  name: string;
  phone: string;
  updatedAt: string;
}

export interface CreateUserDto {
  email: string;
  isVerified: boolean;
  name: string;
  password: string;
  phone: string;
}

export interface AuthEntity {
  accessToken: string;
}

export interface LoginDto {
  email: string;
  password: string;
}

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

export const useAppControllerGetDataHook = () => {
  const appControllerGetData = useAppControllerGetDataMutator<void>();

  return (signal?: AbortSignal) => {
    return appControllerGetData({ url: `/api`, method: 'GET', signal });
  };
};

export const getAppControllerGetDataQueryKey = () => {
  return [`/api`] as const;
};

export const useAppControllerGetDataInfiniteQueryOptions = <
  TData = Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>,
  TError = AppControllerGetDataErrorType<unknown>,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAppControllerGetDataQueryKey();

  const appControllerGetData = useAppControllerGetDataHook();

  const queryFn: QueryFunction<
    Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>
  > = ({ signal }) => appControllerGetData(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AppControllerGetDataInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>
>;
export type AppControllerGetDataInfiniteQueryError =
  AppControllerGetDataErrorType<unknown>;

export const useAppControllerGetDataInfinite = <
  TData = Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>,
  TError = AppControllerGetDataErrorType<unknown>,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>,
    TError,
    TData
  >;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useAppControllerGetDataInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const useAppControllerGetDataQueryOptions = <
  TData = Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>,
  TError = AppControllerGetDataErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAppControllerGetDataQueryKey();

  const appControllerGetData = useAppControllerGetDataHook();

  const queryFn: QueryFunction<
    Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>
  > = ({ signal }) => appControllerGetData(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AppControllerGetDataQueryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>
>;
export type AppControllerGetDataQueryError =
  AppControllerGetDataErrorType<unknown>;

export const useAppControllerGetData = <
  TData = Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>,
  TError = AppControllerGetDataErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useAppControllerGetDataHook>>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useAppControllerGetDataQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const useAuthControllerLoginHook = () => {
  const authControllerLogin = useAuthControllerLoginMutator<AuthEntity>();

  return (loginDto: AuthControllerLoginBodyType<LoginDto>) => {
    return authControllerLogin({
      url: `/api/auth/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginDto,
    });
  };
};

export const useAuthControllerLoginMutationOptions = <
  TError = AuthControllerLoginErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useAuthControllerLoginHook>>>,
    TError,
    { data: AuthControllerLoginBodyType<LoginDto> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<ReturnType<typeof useAuthControllerLoginHook>>>,
  TError,
  { data: AuthControllerLoginBodyType<LoginDto> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const authControllerLogin = useAuthControllerLoginHook();

  const mutationFn: MutationFunction<
    Awaited<ReturnType<ReturnType<typeof useAuthControllerLoginHook>>>,
    { data: AuthControllerLoginBodyType<LoginDto> }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerLogin(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerLoginMutationResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useAuthControllerLoginHook>>>
>;
export type AuthControllerLoginMutationBody =
  AuthControllerLoginBodyType<LoginDto>;
export type AuthControllerLoginMutationError =
  AuthControllerLoginErrorType<unknown>;

export const useAuthControllerLogin = <
  TError = AuthControllerLoginErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useAuthControllerLoginHook>>>,
    TError,
    { data: AuthControllerLoginBodyType<LoginDto> },
    TContext
  >;
}) => {
  const mutationOptions = useAuthControllerLoginMutationOptions(options);

  return useMutation(mutationOptions);
};

export const useUsersControllerCreateHook = () => {
  const usersControllerCreate = useUsersControllerCreateMutator<UserEntity>();

  return (createUserDto: UsersControllerCreateBodyType<CreateUserDto>) => {
    return usersControllerCreate({
      url: `/api/users`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createUserDto,
    });
  };
};

export const useUsersControllerCreateMutationOptions = <
  TError = UsersControllerCreateErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerCreateHook>>>,
    TError,
    { data: UsersControllerCreateBodyType<CreateUserDto> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<ReturnType<typeof useUsersControllerCreateHook>>>,
  TError,
  { data: UsersControllerCreateBodyType<CreateUserDto> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const usersControllerCreate = useUsersControllerCreateHook();

  const mutationFn: MutationFunction<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerCreateHook>>>,
    { data: UsersControllerCreateBodyType<CreateUserDto> }
  > = (props) => {
    const { data } = props ?? {};

    return usersControllerCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useUsersControllerCreateHook>>>
>;
export type UsersControllerCreateMutationBody =
  UsersControllerCreateBodyType<CreateUserDto>;
export type UsersControllerCreateMutationError =
  UsersControllerCreateErrorType<unknown>;

export const useUsersControllerCreate = <
  TError = UsersControllerCreateErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerCreateHook>>>,
    TError,
    { data: UsersControllerCreateBodyType<CreateUserDto> },
    TContext
  >;
}) => {
  const mutationOptions = useUsersControllerCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

export const useUsersControllerFindAllHook = () => {
  const usersControllerFindAll =
    useUsersControllerFindAllMutator<UserEntity[]>();

  return (signal?: AbortSignal) => {
    return usersControllerFindAll({ url: `/api/users`, method: 'GET', signal });
  };
};

export const getUsersControllerFindAllQueryKey = () => {
  return [`/api/users`] as const;
};

export const useUsersControllerFindAllInfiniteQueryOptions = <
  TData = Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>,
  TError = UsersControllerFindAllErrorType<unknown>,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUsersControllerFindAllQueryKey();

  const usersControllerFindAll = useUsersControllerFindAllHook();

  const queryFn: QueryFunction<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>
  > = ({ signal }) => usersControllerFindAll(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UsersControllerFindAllInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>
>;
export type UsersControllerFindAllInfiniteQueryError =
  UsersControllerFindAllErrorType<unknown>;

export const useUsersControllerFindAllInfinite = <
  TData = Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>,
  TError = UsersControllerFindAllErrorType<unknown>,
>(options?: {
  query?: UseInfiniteQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>,
    TError,
    TData
  >;
}): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useUsersControllerFindAllInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const useUsersControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>,
  TError = UsersControllerFindAllErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUsersControllerFindAllQueryKey();

  const usersControllerFindAll = useUsersControllerFindAllHook();

  const queryFn: QueryFunction<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>
  > = ({ signal }) => usersControllerFindAll(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UsersControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>
>;
export type UsersControllerFindAllQueryError =
  UsersControllerFindAllErrorType<unknown>;

export const useUsersControllerFindAll = <
  TData = Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>,
  TError = UsersControllerFindAllErrorType<unknown>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindAllHook>>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useUsersControllerFindAllQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const useUsersControllerFindOneHook = () => {
  const usersControllerFindOne = useUsersControllerFindOneMutator<UserEntity>();

  return (id: number, signal?: AbortSignal) => {
    return usersControllerFindOne({
      url: `/api/users/${id}`,
      method: 'GET',
      signal,
    });
  };
};

export const getUsersControllerFindOneQueryKey = (id: number) => {
  return [`/api/users/${id}`] as const;
};

export const useUsersControllerFindOneInfiniteQueryOptions = <
  TData = Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>,
  TError = UsersControllerFindOneErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUsersControllerFindOneQueryKey(id);

  const usersControllerFindOne = useUsersControllerFindOneHook();

  const queryFn: QueryFunction<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>
  > = ({ signal }) => usersControllerFindOne(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UsersControllerFindOneInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>
>;
export type UsersControllerFindOneInfiniteQueryError =
  UsersControllerFindOneErrorType<unknown>;

export const useUsersControllerFindOneInfinite = <
  TData = Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>,
  TError = UsersControllerFindOneErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<
      Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>,
      TError,
      TData
    >;
  },
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useUsersControllerFindOneInfiniteQueryOptions(
    id,
    options,
  );

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const useUsersControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>,
  TError = UsersControllerFindOneErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUsersControllerFindOneQueryKey(id);

  const usersControllerFindOne = useUsersControllerFindOneHook();

  const queryFn: QueryFunction<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>
  > = ({ signal }) => usersControllerFindOne(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type UsersControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>
>;
export type UsersControllerFindOneQueryError =
  UsersControllerFindOneErrorType<unknown>;

export const useUsersControllerFindOne = <
  TData = Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>,
  TError = UsersControllerFindOneErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<ReturnType<typeof useUsersControllerFindOneHook>>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = useUsersControllerFindOneQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const useUsersControllerUpdateHook = () => {
  const usersControllerUpdate = useUsersControllerUpdateMutator<UserEntity>();

  return (
    id: number,
    updateUserDto: UsersControllerUpdateBodyType<UpdateUserDto>,
  ) => {
    return usersControllerUpdate({
      url: `/api/users/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateUserDto,
    });
  };
};

export const useUsersControllerUpdateMutationOptions = <
  TError = UsersControllerUpdateErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerUpdateHook>>>,
    TError,
    { id: number; data: UsersControllerUpdateBodyType<UpdateUserDto> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<ReturnType<typeof useUsersControllerUpdateHook>>>,
  TError,
  { id: number; data: UsersControllerUpdateBodyType<UpdateUserDto> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const usersControllerUpdate = useUsersControllerUpdateHook();

  const mutationFn: MutationFunction<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerUpdateHook>>>,
    { id: number; data: UsersControllerUpdateBodyType<UpdateUserDto> }
  > = (props) => {
    const { id, data } = props ?? {};

    return usersControllerUpdate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useUsersControllerUpdateHook>>>
>;
export type UsersControllerUpdateMutationBody =
  UsersControllerUpdateBodyType<UpdateUserDto>;
export type UsersControllerUpdateMutationError =
  UsersControllerUpdateErrorType<unknown>;

export const useUsersControllerUpdate = <
  TError = UsersControllerUpdateErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerUpdateHook>>>,
    TError,
    { id: number; data: UsersControllerUpdateBodyType<UpdateUserDto> },
    TContext
  >;
}) => {
  const mutationOptions = useUsersControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};

export const useUsersControllerRemoveHook = () => {
  const usersControllerRemove = useUsersControllerRemoveMutator<UserEntity>();

  return (id: number) => {
    return usersControllerRemove({ url: `/api/users/${id}`, method: 'DELETE' });
  };
};

export const useUsersControllerRemoveMutationOptions = <
  TError = UsersControllerRemoveErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerRemoveHook>>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<ReturnType<typeof useUsersControllerRemoveHook>>>,
  TError,
  { id: number },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const usersControllerRemove = useUsersControllerRemoveHook();

  const mutationFn: MutationFunction<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerRemoveHook>>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return usersControllerRemove(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersControllerRemoveMutationResult = NonNullable<
  Awaited<ReturnType<ReturnType<typeof useUsersControllerRemoveHook>>>
>;

export type UsersControllerRemoveMutationError =
  UsersControllerRemoveErrorType<unknown>;

export const useUsersControllerRemove = <
  TError = UsersControllerRemoveErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<ReturnType<typeof useUsersControllerRemoveHook>>>,
    TError,
    { id: number },
    TContext
  >;
}) => {
  const mutationOptions = useUsersControllerRemoveMutationOptions(options);

  return useMutation(mutationOptions);
};

export const getAuthControllerLoginMock = () => ({
  accessToken: faker.word.sample(),
});

export const getUsersControllerCreateMock = () => ({
  createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
  email: faker.word.sample(),
  id: faker.number.int({ min: undefined, max: undefined }),
  isVerified: faker.datatype.boolean(),
  name: faker.word.sample(),
  phone: faker.word.sample(),
  updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
});

export const getUsersControllerFindAllMock = () =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
    email: faker.word.sample(),
    id: faker.number.int({ min: undefined, max: undefined }),
    isVerified: faker.datatype.boolean(),
    name: faker.word.sample(),
    phone: faker.word.sample(),
    updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
  }));

export const getUsersControllerFindOneMock = () => ({
  createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
  email: faker.word.sample(),
  id: faker.number.int({ min: undefined, max: undefined }),
  isVerified: faker.datatype.boolean(),
  name: faker.word.sample(),
  phone: faker.word.sample(),
  updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
});

export const getUsersControllerUpdateMock = () => ({
  createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
  email: faker.word.sample(),
  id: faker.number.int({ min: undefined, max: undefined }),
  isVerified: faker.datatype.boolean(),
  name: faker.word.sample(),
  phone: faker.word.sample(),
  updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
});

export const getUsersControllerRemoveMock = () => ({
  createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
  email: faker.word.sample(),
  id: faker.number.int({ min: undefined, max: undefined }),
  isVerified: faker.datatype.boolean(),
  name: faker.word.sample(),
  phone: faker.word.sample(),
  updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
});

export const getEducalMock = () => [
  http.get('*/api', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  }),
  http.post('*/api/auth/login', async () => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(getAuthControllerLoginMock()), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  }),
  http.post('*/api/users', async () => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(getUsersControllerCreateMock()), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  }),
  http.get('*/api/users', async () => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(getUsersControllerFindAllMock()), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  }),
  http.get('*/api/users/:id', async () => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(getUsersControllerFindOneMock()), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  }),
  http.patch('*/api/users/:id', async () => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(getUsersControllerUpdateMock()), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  }),
  http.delete('*/api/users/:id', async () => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(getUsersControllerRemoveMock()), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  }),
];
